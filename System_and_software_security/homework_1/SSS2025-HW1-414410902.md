# Homework one

## first question :

explain the buffer overflow here

```
void queryLogin()
{
    char sql[256];
    char *p = sql;
    char userid[64];
    char passwd[64];
    strcpy(p, "UPDATE user_data SET passwd = '"); p += strlen(p);
    gets(userid);
    gets(passwd);
    strcpy(p, passwd); p += strlen(p);
    strcpy(p, "' WHERE userid = '"); p += strlen(p);
    strcpy(p, userid); p += strlen(p);
    strcpy(p, "'");
    db_query(sql);
}
```

- by entering a passwork or a username larger than 64 bits it will make the value overflow

- The function uses unsafe, unbounded input (gets, strcpy) and put the inputs into a stack buffer `sql[256]`. Any input larger than the destination size can overflow in the stack memory.

- also The code also builds SQL by using user input, which creates SQL injection risk in addition to buffer overflows.

## Second question :

```
#include <stdio.h>
#include <string.h>
void safe_call_function() {
    char buffer[10];
    char input[100];
    printf("Enter some texts: ");
    gets(input);
    if (strlen(input) < 10) {
        strncpy(buffer, input, sizeof(input));
    } else {
        printf("Input too long!\n");
    }
    printf("Buffer contains: %s\n", buffer);
}

int main() {
    printf("== Fix bug ==\n");
    safe_call_function();
    return 0;
}
```

- this code looks safe but it use get, gets is unsafe, it reads unlimited input and put them in `input[100]` it will overflow it 

- Wrong size argument to `strncpy(buffer, input, sizeof(input))` uses `sizeof(input)` ( max size 100) when copying to buffer (max size 10). That writes up to 100 bytes into a 10-byte destination -> guaranteed stack overflow. This single mistake completely make the code vulnerable.

- also print the buffer even when not initialised, if we go to the else but still print the buffer you will print an uninitialised buffer


## Third question :
